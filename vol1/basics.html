
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=ascii" />
    <title>Functional Programming in Lean &#8212; Software Foundations in Lean 3.4.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Proof by Induction" href="induction.html" />
    <link rel="prev" title="Preface" href="preface.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="functional-programming-in-lean">
<h1>Functional Programming in Lean<a class="headerlink" href="#functional-programming-in-lean" title="Permalink to this headline">&#182;</a></h1>
<p>Source code: <a class="reference external" href="../../../src/basics.lean">basics.lean</a></p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">&#182;</a></h2>
<p>The functional programming style is founded on simple, everyday mathematical
intuition: if a procedure or method has no side effects, then (ignoring
efficiency) all we need to understand about it is how it maps inputs to outputs,
i.e. we can think of it as just a concrete method for computing a mathematical
function. This is one sense of the word &#8220;functional&#8221; in &#8220;functional
programming.&#8221; The direct connection between programs and simple mathematical
objects supports both formal correctness proofs and sound informal reasoning
about program behavior.</p>
<p>The other sense in which functional programming is &#8220;functional&#8221; is that it
emphasizes the use of functions (or methods) as first-class values &#8212; i.e.,
values that can be passed as arguments to other functions, returned as results,
included in data structures, etc. The recognition that functions can be treated
as data gives rise to a host of useful and powerful programming idioms.</p>
<p>Other common features of functional languages include <em>algebraic data types</em> and
<em>pattern matching</em>, which make it easy to construct and manipulate rich data
structures, and sophisticated polymorphic type systems supporting abstraction
and code reuse. Lean offers all of these features.</p>
<p>The first half of this chapter introduces the most essential elements of Lean.
The second half introduces some basic tactics that can be used to prove
properties of Lean programs.</p>
</div>
<div class="section" id="data-and-functions">
<h2>Data and Functions<a class="headerlink" href="#data-and-functions" title="Permalink to this headline">&#182;</a></h2>
<div class="section" id="enumerated-types">
<h3>Enumerated Types<a class="headerlink" href="#enumerated-types" title="Permalink to this headline">&#182;</a></h3>
<p>One notable aspect of Lean is that its set of built-in features is <em>extremely</em>
small. For example, instead of providing the usual palette of atomic data types
(booleans, integers, strings, etc.), Lean offers a powerful mechanism for
defining new data types from scratch, with all these familiar types as
instances. Naturally, the Lean distribution comes preloaded with an extensive
standard library providing definitions of booleans, numbers, and many common
data structures like lists and hash tables. But there is nothing magic or
primitive about these library definitions. To illustrate this, we will
explicitly restate all the definitions we need, before importing them implicitly
from the library.</p>
</div>
<div class="section" id="days-of-the-week">
<h3>Days of the Week<a class="headerlink" href="#days-of-the-week" title="Permalink to this headline">&#182;</a></h3>
<p>To see how this definition mechanism works, let&#8217;s start with a very simple
example. The following declaration tells Lean that we are defining a new set of
data values &#8212; a <em>type</em>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=inductive%20day%20:%20Type%0D%0A%7C%20sunday%20%7C%20monday%20%7C%20tuesday%20%7C%20wednesday%20%7C%20thursday%20%7C%20friday%20%7C%20saturday%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">inductive</span> <span class="n">day</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">sunday</span> <span class="bp">|</span> <span class="n">monday</span> <span class="bp">|</span> <span class="n">tuesday</span> <span class="bp">|</span> <span class="n">wednesday</span> <span class="bp">|</span> <span class="n">thursday</span> <span class="bp">|</span> <span class="n">friday</span> <span class="bp">|</span> <span class="n">saturday</span>
</pre></div>
</div>
</div><p>The type is called day, and its members are monday, tuesday, etc. The second and
following lines of the definition can be read &#8220;monday is a day, tuesday is a
day, etc.&#8221; Having defined day, we can write functions that operate on days.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=def%20next_weekday%20:%20day%20%E2%86%92%20day%0D%0A%7C%20day.sunday%20:=%20day.monday%0D%0A%7C%20day.monday%20:=%20day.tuesday%0D%0A%7C%20day.tuesday%20:=%20day.wednesday%0D%0A%7C%20day.wednesday%20:=%20day.thursday%0D%0A%7C%20day.thursday%20:=%20day.friday%0D%0A%7C%20day.friday%20:=%20day.monday%0D%0A%7C%20day.saturday%20:=%20day.monday%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">def</span> <span class="n">next_weekday</span> <span class="o">:</span> <span class="n">day</span> <span class="bp">&#8594;</span> <span class="n">day</span>
<span class="bp">|</span> <span class="n">day</span><span class="bp">.</span><span class="n">sunday</span> <span class="o">:=</span> <span class="n">day</span><span class="bp">.</span><span class="n">monday</span>
<span class="bp">|</span> <span class="n">day</span><span class="bp">.</span><span class="n">monday</span> <span class="o">:=</span> <span class="n">day</span><span class="bp">.</span><span class="n">tuesday</span>
<span class="bp">|</span> <span class="n">day</span><span class="bp">.</span><span class="n">tuesday</span> <span class="o">:=</span> <span class="n">day</span><span class="bp">.</span><span class="n">wednesday</span>
<span class="bp">|</span> <span class="n">day</span><span class="bp">.</span><span class="n">wednesday</span> <span class="o">:=</span> <span class="n">day</span><span class="bp">.</span><span class="n">thursday</span>
<span class="bp">|</span> <span class="n">day</span><span class="bp">.</span><span class="n">thursday</span> <span class="o">:=</span> <span class="n">day</span><span class="bp">.</span><span class="n">friday</span>
<span class="bp">|</span> <span class="n">day</span><span class="bp">.</span><span class="n">friday</span> <span class="o">:=</span> <span class="n">day</span><span class="bp">.</span><span class="n">monday</span>
<span class="bp">|</span> <span class="n">day</span><span class="bp">.</span><span class="n">saturday</span> <span class="o">:=</span> <span class="n">day</span><span class="bp">.</span><span class="n">monday</span>
</pre></div>
</div>
</div><p>One thing to note is that the argument and return types of this function are
explicitly declared. Like most functional programming languages, Lean can often
figure out these types for itself when they are not given explicitly &#8212; i.e., it
can do type inference &#8212; but we&#8217;ll generally include them to make reading easier.</p>
<p>Having defined a function, we should check that it works on some examples. There
are actually three different ways to do this in Lean. First, we can use the
command <code class="docutils literal notranslate"><span class="pre">#reduce</span></code> to evaluate a compound expression involving
<code class="docutils literal notranslate"><span class="pre">next_weekday</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=#reduce%20next_weekday%20day.sunday%0A/-%20==%3E%20day.monday%20-/" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="bp">#</span><span class="n">reduce</span> <span class="n">next_weekday</span> <span class="n">day</span><span class="bp">.</span><span class="n">sunday</span>
<span class="c">/-</span><span class="cm"> ==&gt; day.monday -/</span>
</pre></div>
</div>
</div><p>(We show Lean&#8217;s responses in comments, but, if you have a computer handy, this
would be an excellent moment to fire up the Lean server under your favorite text
editor &#8212; either VSCode or Emacs &#8212; and try this for yourself. Load this file,
basics.lean, from the book&#8217;s Lean sources, find the above example, submit it to
Lean, and observe the result.)</p>
<p>Second, we can record what we expect the result to be in the form of a Lean
example:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=example%20:%20next_weekday%20(next_weekday%20day.saturday)%20=%20day.tuesday%20:=%20rfl%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">next_weekday</span> <span class="o">(</span><span class="n">next_weekday</span> <span class="n">day</span><span class="bp">.</span><span class="n">saturday</span><span class="o">)</span> <span class="bp">=</span> <span class="n">day</span><span class="bp">.</span><span class="n">tuesday</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><p>This declaration makes an assertion (that the second weekday after
saturday is tuesday). Having made the assertion, we ask Lean to verify
it, using the <code class="docutils literal notranslate"><span class="pre">rfl</span></code> term.</p>
<p>The details are not important for now (we&#8217;ll come back to them in a
bit), but essentially this can be read as &#8220;the assertion we&#8217;ve just
made can be proved by observing that both sides of the equality
evaluate to the same thing.&#8221;</p>
<p>Third, we can ask Lean to extract, from our <code class="docutils literal notranslate"><span class="pre">def</span></code>, a program in some other,
more conventional, programming language (C++) with a high-performance compiler.
This facility is very interesting, since it gives us a way to go from
proved-correct algorithms written in Lean to efficient machine code. (Of course,
we are trusting the correctness of the C++ compiler, and of Lean&#8217;s extraction
facility itself, but this is still a big step forward from the way most software
is developed today.) Indeed, this is one of the main uses for which Lean was
developed. We&#8217;ll come back to this topic in later chapters.</p>
</div>
<div class="section" id="booleans">
<h3>Booleans<a class="headerlink" href="#booleans" title="Permalink to this headline">&#182;</a></h3>
<p>In a similar way, we can define the standard type <code class="docutils literal notranslate"><span class="pre">bool</span></code> of
booleans, with members <code class="docutils literal notranslate"><span class="pre">tt</span></code> and <code class="docutils literal notranslate"><span class="pre">ff</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=inductive%20bool'%20:%20Type%0D%0A%7C%20tt%20%7C%20ff%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">inductive</span> <span class="n">bool&#39;</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="bp">|</span> <span class="n">ff</span>
</pre></div>
</div>
</div><p>Although we are rolling our own booleans here for the sake of building
up everything from scratch, Lean does, of course, provide a default
implementation of the booleans, together with a multitude of useful
functions and lemmas. (Take a look at <code class="docutils literal notranslate"><span class="pre">/library/init/core.lean/</span></code> if
you&#8217;re interested.) Whenever possible, we&#8217;ll name our own definitions
and theorems so that they exactly coincide with the ones in the
standard library, but with a quote mark.</p>
<p>Functions over booleans can be defined in the same way as above:</p>
<p>These examples show the use of Lean&#8217;s <em>equation compiler</em> for
definitions. The corresponding multi-argument application syntax is
illustrated by the following &#8220;unit tests,&#8221; which constitute a complete
specification &#8212; a truth table &#8212; for the <code class="docutils literal notranslate"><span class="pre">bor</span></code> function:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=example%20:%20bor'%20tt%20ff%20=%20tt%20:=%20rfl%0D%0Aexample%20:%20bor'%20ff%20ff%20=%20ff%20:=%20rfl%0D%0Aexample%20:%20bor'%20ff%20tt%20=%20tt%20:=%20rfl%0D%0Aexample%20:%20bor'%20tt%20tt%20=%20tt%20:=%20rfl%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">bor&#39;</span> <span class="n">tt</span> <span class="n">ff</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">bor&#39;</span> <span class="n">ff</span> <span class="n">ff</span> <span class="bp">=</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">bor&#39;</span> <span class="n">ff</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">bor&#39;</span> <span class="n">tt</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><div class="section" id="exercise-1-star-bnand">
<h4>Exercise: 1 star (bnand)<a class="headerlink" href="#exercise-1-star-bnand" title="Permalink to this headline">&#182;</a></h4>
<p>Remove <code class="docutils literal notranslate"><span class="pre">sorry</span></code> and complete the definition of the following
function; then make sure that the <code class="docutils literal notranslate"><span class="pre">example</span></code> assertions below can each be
verified by Lean. (Remove <code class="docutils literal notranslate"><span class="pre">sorry</span></code> and fill in each proof, following
the model of the <code class="docutils literal notranslate"><span class="pre">bor'</span></code> tests above.) The function should return <code class="docutils literal notranslate"><span class="pre">tt</span></code> if
either or both of its inputs are <code class="docutils literal notranslate"><span class="pre">ff</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=def%20bnand%20:%20bool'%20%E2%86%92%20bool'%20%E2%86%92%20bool'%20:=%0D%0Asorry%20--%20replace%20%60:=%20sorry%60%20with%20your%20definition%0D%0A%0D%0Alemma%20test_bnand1%20:%20bnand%20tt%20ff%20=%20tt%20:=%20sorry%20--%20fill%20in%20here%0D%0Alemma%20test_bnand2%20:%20bnand%20ff%20ff%20=%20tt%20:=%20sorry%20--%20fill%20in%20here%0D%0Alemma%20test_bnand3%20:%20bnand%20ff%20tt%20=%20tt%20:=%20sorry%20--%20fill%20in%20here%0D%0Alemma%20test_bnand4%20:%20bnand%20tt%20tt%20=%20ff%20:=%20sorry%20--%20fill%20in%20here%0D%0A%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">def</span> <span class="n">bnand</span> <span class="o">:</span> <span class="n">bool&#39;</span> <span class="bp">&#8594;</span> <span class="n">bool&#39;</span> <span class="bp">&#8594;</span> <span class="n">bool&#39;</span> <span class="o">:=</span>
<span class="n">sorry</span> <span class="c1">-- replace `:= sorry` with your definition</span>

<span class="kn">lemma</span> <span class="n">test_bnand1</span> <span class="o">:</span> <span class="n">bnand</span> <span class="n">tt</span> <span class="n">ff</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="c1">-- fill in here</span>
<span class="kn">lemma</span> <span class="n">test_bnand2</span> <span class="o">:</span> <span class="n">bnand</span> <span class="n">ff</span> <span class="n">ff</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="c1">-- fill in here</span>
<span class="kn">lemma</span> <span class="n">test_bnand3</span> <span class="o">:</span> <span class="n">bnand</span> <span class="n">ff</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="c1">-- fill in here</span>
<span class="kn">lemma</span> <span class="n">test_bnand4</span> <span class="o">:</span> <span class="n">bnand</span> <span class="n">tt</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="c1">-- fill in here</span>
</pre></div>
</div>
</div></div>
<div class="section" id="exercise-1-star-band3">
<h4>Exercise: 1 star (band3)<a class="headerlink" href="#exercise-1-star-band3" title="Permalink to this headline">&#182;</a></h4>
<p>Do the same for the band3 function below. This function should return
true when all of its inputs are <code class="docutils literal notranslate"><span class="pre">tt</span></code>, and <code class="docutils literal notranslate"><span class="pre">ff</span></code> otherwise.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=def%20band3%20(b1%20:%20bool')%20(b2%20:%20bool')%20(b3%20:%20bool')%20:%20bool'%20:=%0D%0Asorry%20--%20replace%20%60:=%20sorry%60%20with%20your%20definition%0D%0A%0D%0A%0D%0A#check%20bool'.tt%0D%0A/-%20===%3E%20tt%20:%20bool'%20-/%0D%0A#check%20(bnot'%20tt)%0D%0A/-%20===%3E%20bnot'%20tt%20:%20bool'%20-/%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">def</span> <span class="n">band3</span> <span class="o">(</span><span class="n">b1</span> <span class="o">:</span> <span class="n">bool&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">b2</span> <span class="o">:</span> <span class="n">bool&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">b3</span> <span class="o">:</span> <span class="n">bool&#39;</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool&#39;</span> <span class="o">:=</span>
<span class="n">sorry</span> <span class="c1">-- replace `:= sorry` with your definition</span>


<span class="bp">#</span><span class="kn">check</span> <span class="n">bool&#39;</span><span class="bp">.</span><span class="n">tt</span>
<span class="c">/-</span><span class="cm"> ===&gt; tt : bool&#39; -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">bnot&#39;</span> <span class="n">tt</span><span class="o">)</span>
<span class="c">/-</span><span class="cm"> ===&gt; bnot&#39; tt : bool&#39; -/</span>
</pre></div>
</div>
</div></div>
</div>
<div class="section" id="function-types">
<h3>Function Types<a class="headerlink" href="#function-types" title="Permalink to this headline">&#182;</a></h3>
<p>Every expression in Lean has a type, describing what sort of thing it
computes. The <code class="docutils literal notranslate"><span class="pre">#check</span></code> command asks Lean to print the type of an
expression.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=#check%20bool'.tt%0D%0A/-%20===%3E%20tt%20:%20bool'%20-/%0D%0A#check%20(bnot'%20tt)%0D%0A/-%20===%3E%20bnot'%20tt%20:%20bool'%20-/%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="n">bool&#39;</span><span class="bp">.</span><span class="n">tt</span>
<span class="c">/-</span><span class="cm"> ===&gt; tt : bool&#39; -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">bnot&#39;</span> <span class="n">tt</span><span class="o">)</span>
<span class="c">/-</span><span class="cm"> ===&gt; bnot&#39; tt : bool&#39; -/</span>
</pre></div>
</div>
</div><p>Functions like negb itself are also data values, just like true and
false. Their types are called function types, and they are written
with arrows.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=#check%20bnot'%0D%0A/-%20===%3E%20bnot'%20:%20bool'%20%E2%86%92%20bool'%20-/%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="n">bnot&#39;</span>
<span class="c">/-</span><span class="cm"> ===&gt; bnot&#39; : bool&#39; &#8594; bool&#39; -/</span>
</pre></div>
</div>
</div><p>The type of <code class="docutils literal notranslate"><span class="pre">bnot'</span></code>, written <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">&#8594;</span> <span class="pre">bool</span></code> and pronounced &#8220;bool arrow
bool,&#8221; can be read, &#8220;Given an input of type bool, this function
produces an output of type bool.&#8221; Similarly, the type of <code class="docutils literal notranslate"><span class="pre">band'</span></code>, written
<code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">&#8594;</span> <span class="pre">bool</span> <span class="pre">&#8594;</span> <span class="pre">bool</span></code>, can be read, &#8220;Given two inputs, both of type bool,
this function produces an output of type bool.&#8221;</p>
</div>
<div class="section" id="compound-types">
<h3>Compound Types<a class="headerlink" href="#compound-types" title="Permalink to this headline">&#182;</a></h3>
<p>The types we have defined so far are examples of &#8220;enumerated types&#8221;:
their definitions explicitly enumerate a finite set of elements, each
of which is just a bare constructor. Here is a more interesting type
definition, where one of the constructors takes an argument:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=inductive%20rgb%20:%20Type%0D%0A%20%20%7C%20red%20:%20rgb%0D%0A%20%20%7C%20green%20:%20rgb%0D%0A%20%20%7C%20blue%20:%20rgb%0D%0Ainductive%20color%20:%20Type%0D%0A%20%20%7C%20black%20:%20color%0D%0A%20%20%7C%20white%20:%20color%0D%0A%20%20%7C%20primary%20:%20rgb%20%E2%86%92%20color%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">inductive</span> <span class="n">rgb</span> <span class="o">:</span> <span class="kt">Type</span>
  <span class="bp">|</span> <span class="n">red</span> <span class="o">:</span> <span class="n">rgb</span>
  <span class="bp">|</span> <span class="n">green</span> <span class="o">:</span> <span class="n">rgb</span>
  <span class="bp">|</span> <span class="n">blue</span> <span class="o">:</span> <span class="n">rgb</span>
<span class="kn">inductive</span> <span class="n">color</span> <span class="o">:</span> <span class="kt">Type</span>
  <span class="bp">|</span> <span class="n">black</span> <span class="o">:</span> <span class="n">color</span>
  <span class="bp">|</span> <span class="n">white</span> <span class="o">:</span> <span class="n">color</span>
  <span class="bp">|</span> <span class="n">primary</span> <span class="o">:</span> <span class="n">rgb</span> <span class="bp">&#8594;</span> <span class="n">color</span>
</pre></div>
</div>
</div><p>Let&#8217;s look at this in a little more detail.</p>
<p>Every inductively defined type (<code class="docutils literal notranslate"><span class="pre">day</span></code>, <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">rgb</span></code>, <code class="docutils literal notranslate"><span class="pre">color</span></code>,
etc.) contains a set of constructor expressions built from
constructors like <code class="docutils literal notranslate"><span class="pre">red</span></code>, <code class="docutils literal notranslate"><span class="pre">primary</span></code>, <code class="docutils literal notranslate"><span class="pre">tt</span></code>, <code class="docutils literal notranslate"><span class="pre">ff</span></code>, <code class="docutils literal notranslate"><span class="pre">monday</span></code>,
etc. The definitions of <code class="docutils literal notranslate"><span class="pre">rgb</span></code> and <code class="docutils literal notranslate"><span class="pre">color</span></code> say how expressions in
the sets <code class="docutils literal notranslate"><span class="pre">rgb</span></code> and <code class="docutils literal notranslate"><span class="pre">color</span></code> can be built:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">red</span></code>, <code class="docutils literal notranslate"><span class="pre">green</span></code>, and <code class="docutils literal notranslate"><span class="pre">blue</span></code> are the constructors of <code class="docutils literal notranslate"><span class="pre">rgb</span></code>;</li>
<li><code class="docutils literal notranslate"><span class="pre">black</span></code>, <code class="docutils literal notranslate"><span class="pre">white</span></code>, and <code class="docutils literal notranslate"><span class="pre">primary</span></code> are the constructors of
<code class="docutils literal notranslate"><span class="pre">color</span></code>;</li>
<li>the expression <code class="docutils literal notranslate"><span class="pre">red</span></code> belongs to the set <code class="docutils literal notranslate"><span class="pre">rgb</span></code>, as do the
expressions <code class="docutils literal notranslate"><span class="pre">green</span></code> and <code class="docutils literal notranslate"><span class="pre">blue</span></code>;</li>
<li>the expressions <code class="docutils literal notranslate"><span class="pre">black</span></code> and <code class="docutils literal notranslate"><span class="pre">white</span></code> belong to the set <code class="docutils literal notranslate"><span class="pre">color</span></code>;</li>
<li>if <code class="docutils literal notranslate"><span class="pre">p</span></code> is an expression belonging to the set <code class="docutils literal notranslate"><span class="pre">rgb</span></code>, then
<code class="docutils literal notranslate"><span class="pre">primary</span> <span class="pre">p</span></code> (pronounced &#8220;the constructor <code class="docutils literal notranslate"><span class="pre">primary</span></code> applied to
the argument <code class="docutils literal notranslate"><span class="pre">p</span></code>&#8221;) is an expression belonging to the set
<code class="docutils literal notranslate"><span class="pre">color</span></code>; and</li>
<li>expressions formed in these ways are the only ones belonging to the
sets <code class="docutils literal notranslate"><span class="pre">rgb</span></code> and <code class="docutils literal notranslate"><span class="pre">color</span></code>.</li>
</ul>
</div></blockquote>
<p>We can define functions on colors using pattern matching just as we
have done for day and bool.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=def%20monochrome%20:%20color%20%E2%86%92%20bool'%0D%0A%20%20%7C%20black%20:=%20tt%0D%0A%20%20%7C%20white%20:=%20tt%0D%0A%20%20%7C%20(primary%20p)%20:=%20ff%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">def</span> <span class="n">monochrome</span> <span class="o">:</span> <span class="n">color</span> <span class="bp">&#8594;</span> <span class="n">bool&#39;</span>
  <span class="bp">|</span> <span class="n">black</span> <span class="o">:=</span> <span class="n">tt</span>
  <span class="bp">|</span> <span class="n">white</span> <span class="o">:=</span> <span class="n">tt</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">primary</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ff</span>
</pre></div>
</div>
</div><p>Since the primary constructor takes an argument, a pattern matching
primary should include either a variable (as above) or a constant of
appropriate type (as below).</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=def%20isred%20:%20color%20%E2%86%92%20bool'%0D%0A%20%20%7C%20black%20:=%20ff%0D%0A%20%20%7C%20white%20:=%20ff%0D%0A%20%20%7C%20(primary%20red)%20:=%20tt%0D%0A%20%20%7C%20(primary%20_)%20%20%20:=%20ff%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">def</span> <span class="n">isred</span> <span class="o">:</span> <span class="n">color</span> <span class="bp">&#8594;</span> <span class="n">bool&#39;</span>
  <span class="bp">|</span> <span class="n">black</span> <span class="o">:=</span> <span class="n">ff</span>
  <span class="bp">|</span> <span class="n">white</span> <span class="o">:=</span> <span class="n">ff</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">primary</span> <span class="n">red</span><span class="o">)</span> <span class="o">:=</span> <span class="n">tt</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">primary</span> <span class="bp">_</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">ff</span>
</pre></div>
</div>
</div><p>The pattern <code class="docutils literal notranslate"><span class="pre">primary</span> <span class="pre">_</span></code> here is shorthand for &#8220;primary applied to any
rgb constructor except red.&#8221; (The wildcard pattern <code class="docutils literal notranslate"><span class="pre">_</span></code> has the same
effect as the dummy pattern variable <code class="docutils literal notranslate"><span class="pre">p</span></code> in the definition of
<code class="docutils literal notranslate"><span class="pre">monochrome</span></code>.)</p>
</div>
<div class="section" id="namespaces">
<h3>Namespaces<a class="headerlink" href="#namespaces" title="Permalink to this headline">&#182;</a></h3>
<p>Lean provides a name space system, to aid in organizing large
developments. If we enclose a collection of declarations between
<code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">X</span></code> markers, then, in the remainder of the
file after the End, these definitions are referred to by names like
<code class="docutils literal notranslate"><span class="pre">X.foo</span></code> instead of just <code class="docutils literal notranslate"><span class="pre">foo</span></code>. We will use this language feature
to introduce the definition of the type nat in an inner module so that
it does not interfere with the one from the standard library (which we
want to use in the rest because it comes with a tiny bit of convenient
special notation).</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=namespace%20nat_playground%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">namespace</span> <span class="n">nat_playground</span>
</pre></div>
</div>
</div></div>
<div class="section" id="numbers">
<h3>Numbers<a class="headerlink" href="#numbers" title="Permalink to this headline">&#182;</a></h3>
<p>An even more interesting way of defining a type is to allow its
constructors to take arguments from the very same type &#8212; that is, to
allow the rules describing its elements to be <em>inductive</em>.</p>
<p>For example, we can define (a unary representation of) natural numbers
as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=inductive%20nat%20:%20Type%0D%0A%20%20%7C%20zero%20:%20nat%0D%0A%20%20%7C%20succ%20:%20nat%20%E2%86%92%20nat.%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">inductive</span> <span class="n">nat</span> <span class="o">:</span> <span class="kt">Type</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">nat</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span><span class="bp">.</span>
</pre></div>
</div>
</div><dl class="docutils">
<dt>The clauses of this definition can be read:</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal notranslate"><span class="pre">zero</span></code> is a natural number.</li>
<li><code class="docutils literal notranslate"><span class="pre">succ</span></code> can be put in front of a natural number to yield another
one &#8212; if <code class="docutils literal notranslate"><span class="pre">n</span></code> is a natural number, then <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">n</span></code> is too.</li>
</ul>
</dd>
</dl>
<p>Again, let&#8217;s look at this in a little more detail. The definition of
<code class="docutils literal notranslate"><span class="pre">nat</span></code> says how expressions in the set <code class="docutils literal notranslate"><span class="pre">nat</span></code> can be built:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">zero</span></code> and <code class="docutils literal notranslate"><span class="pre">succ</span></code> are constructors;</li>
<li>the expression <code class="docutils literal notranslate"><span class="pre">zero</span></code> belongs to the set <code class="docutils literal notranslate"><span class="pre">nat</span></code>;</li>
<li>if <code class="docutils literal notranslate"><span class="pre">n</span></code> is an expression belonging to the set <code class="docutils literal notranslate"><span class="pre">nat</span></code>, then <code class="docutils literal notranslate"><span class="pre">succ</span>
<span class="pre">n</span></code> is also an expression belonging to the set <code class="docutils literal notranslate"><span class="pre">nat</span></code>; and</li>
<li>expressions formed in these two ways are the only ones belonging to
the set <code class="docutils literal notranslate"><span class="pre">nat</span></code>.</li>
</ul>
</div></blockquote>
<p>The same rules apply for our definitions of day, bool, color, etc.</p>
<p>The above conditions are the precise force of the Inductive
declaration. They imply that the expression <code class="docutils literal notranslate"><span class="pre">zero</span></code>, the expression
<code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">zero</span></code>, the expression <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">(succ</span> <span class="pre">zero)</span></code>, the expression
<code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">(succ</span> <span class="pre">(succ</span> <span class="pre">zero))</span></code>, and so on all belong to the set nat,
while other expressions built from data constructors, like <code class="docutils literal notranslate"><span class="pre">tt</span></code>,
<code class="docutils literal notranslate"><span class="pre">andb</span> <span class="pre">tt</span> <span class="pre">ff</span></code>, <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">(succ</span> <span class="pre">ff)</span></code>, and <code class="docutils literal notranslate"><span class="pre">zero</span> <span class="pre">(zero</span> <span class="pre">(zero</span> <span class="pre">succ))</span></code> do
not.</p>
<p>A critical point here is that what we&#8217;ve done so far is just to define
a representation of numbers: a way of writing them down. The names
<code class="docutils literal notranslate"><span class="pre">zero</span></code> and <code class="docutils literal notranslate"><span class="pre">succ</span></code> are arbitrary, and at this point they have no
special meaning &#8212; they are just two different marks that we can use to
write down numbers (together with a rule that says any <code class="docutils literal notranslate"><span class="pre">nat</span></code> will be
written as some string of <code class="docutils literal notranslate"><span class="pre">succ</span></code> marks followed by a <code class="docutils literal notranslate"><span class="pre">zero</span></code>). If
we like, we can write essentially the same definition this way:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=inductive%20nat'%20:%20Type%0D%0A%20%20%7C%20stop%20:%20nat'%0D%0A%20%20%7C%20tick%20:%20nat'%20%E2%86%92%20nat'%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">inductive</span> <span class="n">nat&#39;</span> <span class="o">:</span> <span class="kt">Type</span>
  <span class="bp">|</span> <span class="n">stop</span> <span class="o">:</span> <span class="n">nat&#39;</span>
  <span class="bp">|</span> <span class="n">tick</span> <span class="o">:</span> <span class="n">nat&#39;</span> <span class="bp">&#8594;</span> <span class="n">nat&#39;</span>
</pre></div>
</div>
</div><p>The <em>interpretation</em> of these marks comes from how we use them to
compute.</p>
<p>We can do this by writing functions that pattern match on
representations of natural numbers just as we did above with booleans
and days &#8212; for example, here is the predecessor function:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20nat_playground.nat%0D%0Adef%20pred%20:%20nat%20%E2%86%92%20nat%0D%0A%20%20%7C%20zero%20:=%20zero%0D%0A%20%20%7C%20(succ%20n)%20:=%20n%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span> <span class="n">nat_playground</span><span class="bp">.</span><span class="n">nat</span>
<span class="n">def</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span>
</pre></div>
</div>
</div><p>The second branch can be read: &#8220;if <code class="docutils literal notranslate"><span class="pre">n</span></code> has the form <code class="docutils literal notranslate"><span class="pre">succ</span> <span class="pre">n'</span></code> for
some <code class="docutils literal notranslate"><span class="pre">n'</span></code>, then return <code class="docutils literal notranslate"><span class="pre">n'</span></code>.&#8221;</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=end%20nat_playground%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">end</span> <span class="n">nat_playground</span>
</pre></div>
</div>
</div><p>Because natural numbers are such a pervasive form of data, Lean
provides a tiny bit of built-in magic for parsing and printing them:
ordinary arabic numerals can be used as an alternative to the &#8220;unary&#8221;
notation defined by the constructors <code class="docutils literal notranslate"><span class="pre">succ</span></code> and <code class="docutils literal notranslate"><span class="pre">zero</span></code>. Lean
prints numbers in arabic form by default:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20nat%0D%0A#check%20succ%20(succ%20(succ%20(succ%20zero)))%0D%0A/-%20===%3E%204%20:%20%E2%84%95%20-/%0D%0A%0D%0Adef%20minustwo%20:%20nat%20%E2%86%92%20nat%0D%0A%20%20%7C%20zero%20:=%20zero%0D%0A%20%20%7C%20(succ%20zero)%20:=%20zero%0D%0A%20%20%7C%20(succ%20(succ%20n))%20:=%20n%0D%0A%0D%0A#reduce%20(minustwo%204).%0D%0A/-%20===%3E%202%20-/%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span> <span class="n">nat</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">zero</span><span class="o">)))</span>
<span class="c">/-</span><span class="cm"> ===&gt; 4 : &#8469; -/</span>

<span class="n">def</span> <span class="n">minustwo</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">zero</span><span class="o">)</span> <span class="o">:=</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="n">n</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="o">(</span><span class="n">minustwo</span> <span class="mi">4</span><span class="o">)</span><span class="bp">.</span>
<span class="c">/-</span><span class="cm"> ===&gt; 2 -/</span>
</pre></div>
</div>
</div><p>The constructor <code class="docutils literal notranslate"><span class="pre">succ</span></code> has the type <code class="docutils literal notranslate"><span class="pre">nat</span> <span class="pre">&#8594;</span> <span class="pre">nat</span></code>, just like
<code class="docutils literal notranslate"><span class="pre">pred</span></code> and functions like <code class="docutils literal notranslate"><span class="pre">minustwo</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=#check%20succ%0A#check%20pred%0A#check%20minustwo" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="n">succ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">pred</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">minustwo</span>
</pre></div>
</div>
</div><p>These are all things that can be applied to a number to yield a
number. However, there is a fundamental difference between the first
one and the other two: functions like <code class="docutils literal notranslate"><span class="pre">pred</span></code> and <code class="docutils literal notranslate"><span class="pre">minustwo</span></code> come
with computation rules &#8212; e.g., the definition of <code class="docutils literal notranslate"><span class="pre">pred</span></code> says that
<code class="docutils literal notranslate"><span class="pre">pred</span> <span class="pre">2</span></code> can be simplified to <code class="docutils literal notranslate"><span class="pre">1</span></code> &#8212; while the definition of
<code class="docutils literal notranslate"><span class="pre">succ</span></code> has no such behavior attached. Although it is like a function
in the sense that it can be applied to an argument, it does not do
anything at all! It is just a way of writing down numbers. (Think
about standard arabic numerals: the numeral <code class="docutils literal notranslate"><span class="pre">1</span></code> is not a
computation; it&#8217;s a piece of data. When we write <code class="docutils literal notranslate"><span class="pre">111</span></code> to mean the
number one hundred and eleven, we are using <code class="docutils literal notranslate"><span class="pre">1</span></code>, three times, to
write down a concrete representation of a number.)</p>
<p>For most function definitions over numbers, just pattern matching is
not enough: we also need recursion. For example, to check that a
number <code class="docutils literal notranslate"><span class="pre">n</span></code> is even, we may need to recursively check whether <code class="docutils literal notranslate"><span class="pre">n-2</span></code>
is even:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=def%20evenb%20:%20nat%20%E2%86%92%20bool%0D%0A%20%20%7C%20zero%20:=%20true%0D%0A%20%20%7C%20(succ%20zero)%20:=%20false%0D%0A%20%20%7C%20(succ%20(succ%20n))%20:=%20evenb%20n%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">def</span> <span class="n">evenb</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">bool</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">true</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">zero</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="n">evenb</span> <span class="n">n</span>
</pre></div>
</div>
</div><p>We can define <code class="docutils literal notranslate"><span class="pre">oddb</span></code> by a similar recursive function, but here is a
simpler definition:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=def%20oddb%20(n:nat)%20:%20bool%20:=%20bnot%20(evenb%20n)%0D%0A%0D%0Aexample%20:%20oddb%201%20=%20tt%20:=%20rfl%0D%0A%0D%0Aexample%20:%20oddb%204%20=%20ff%20:=%20rfl%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">def</span> <span class="n">oddb</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">bnot</span> <span class="o">(</span><span class="n">evenb</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">oddb</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">oddb</span> <span class="mi">4</span> <span class="bp">=</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><p>(You will notice if you step through these proofs that simpl actually
has no effect on the goal &#8212; all of the work is done by
reflexivity. We&#8217;ll see more about why that is shortly.)</p>
<p>Naturally, we can also define multi-argument functions by recursion.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=namespace%20nat_playground2%0D%0A%0D%0Adef%20plus%20:%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0D%0A%20%20%7C%20zero%20m%20:=%20m%0D%0A%20%20%7C%20(succ%20n)%20m%20:=%20succ%20(plus%20n%20m)%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">namespace</span> <span class="n">nat_playground2</span>

<span class="n">def</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">plus</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Adding three to two now gives us five, as we&#8217;d expect.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=#reduce%20(plus%203%202)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="bp">#</span><span class="n">reduce</span> <span class="o">(</span><span class="n">plus</span> <span class="mi">3</span> <span class="mi">2</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The simplification that Lean performs to reach this conclusion can be visualized as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=/-%20%20plus%20(succ%20(succ%20(succ%20O)))%20(succ%20(succ%20O))%0D%0A==%3E%20succ%20(plus%20(succ%20(succ%20O))%20(succ%20(succ%20O)))%0D%0A%20%20%20%20%20%20by%20the%20second%20clause%20of%20the%20match%0D%0A==%3E%20succ%20(succ%20(plus%20(succ%20O)%20(succ%20(succ%20O))))%0D%0A%20%20%20%20%20%20by%20the%20second%20clause%20of%20the%20match%0D%0A==%3E%20succ%20(succ%20(succ%20(plus%20O%20(succ%20(succ%20O)))))%0D%0A%20%20%20%20%20%20by%20the%20second%20clause%20of%20the%20match%0D%0A==%3E%20succ%20(succ%20(succ%20(succ%20(succ%20O))))%0D%0A%20%20%20%20%20%20by%20the%20first%20clause%20of%20the%20match%0D%0A-/%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span><span class="cm">  plus (succ (succ (succ O))) (succ (succ O))</span>
<span class="cm">==&gt; succ (plus (succ (succ O)) (succ (succ O)))</span>
<span class="cm">      by the second clause of the match</span>
<span class="cm">==&gt; succ (succ (plus (succ O) (succ (succ O))))</span>
<span class="cm">      by the second clause of the match</span>
<span class="cm">==&gt; succ (succ (succ (plus O (succ (succ O)))))</span>
<span class="cm">      by the second clause of the match</span>
<span class="cm">==&gt; succ (succ (succ (succ (succ O))))</span>
<span class="cm">      by the first clause of the match</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>You can match two expressions at once by putting a comma between them:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=def%20minus%20:%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0D%0A%20%20%7C%20zero%20_%20:=%20zero%0D%0A%20%20%7C%20n&#64;(succ%20_)%20zero%20:=%20n%0D%0A%20%20%7C%20(succ%20n)%20(succ%20m)%20:=%20minus%20n%20m%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">def</span> <span class="n">minus</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="n">n</span><span class="bp">@</span><span class="o">(</span><span class="n">succ</span> <span class="bp">_</span><span class="o">)</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="n">minus</span> <span class="n">n</span> <span class="n">m</span>
</pre></div>
</div>
</div><p>Again, the <code class="docutils literal notranslate"><span class="pre">_</span></code> in the first line is a wildcard pattern. Writing
<code class="docutils literal notranslate"><span class="pre">_</span></code> in a pattern is the same as writing some variable that doesn&#8217;t
get used on the right-hand side. This avoids the need to invent a
variable name.</p>
<p>As a notational convenience, if two or more arguments have the same
type, they can be written together. In the following definition, <code class="docutils literal notranslate"><span class="pre">(n</span>
<span class="pre">m</span> <span class="pre">:</span> <span class="pre">nat)</span></code> means just the same as if we had written <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">:</span> <span class="pre">nat)</span> <span class="pre">(m</span> <span class="pre">:</span>
<span class="pre">nat)</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=def%20subtracted_from%20(m%20n%20:%20nat)%20:%20nat%20:=%20minus%20n%20m%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">def</span> <span class="n">subtracted_from</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">minus</span> <span class="n">n</span> <span class="n">m</span>
</pre></div>
</div>
</div><p>So far, we have only displayed function arguments by either naming all
of them or matching them in a function&#8217;s equation. The function
<code class="docutils literal notranslate"><span class="pre">mult</span></code> below illustrates how we can mix and match the two styles:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=def%20mult%20(m%20:%20nat)%20:%20nat%20%E2%86%92%20nat%0D%0A%20%20%7C%20zero%20:=%20zero%0D%0A%20%20%7C%20(succ%20n)%20:=%20plus%20m%20(mult%20n)%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">def</span> <span class="n">mult</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">plus</span> <span class="n">m</span> <span class="o">(</span><span class="n">mult</span> <span class="n">n</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Notice how the recursive call to <code class="docutils literal notranslate"><span class="pre">mult</span></code>, <code class="docutils literal notranslate"><span class="pre">(mult</span> <span class="pre">n)</span></code> is given only
one argument. This is because the named arguments &#8212; <code class="docutils literal notranslate"><span class="pre">m</span></code> in our
case &#8212; implicitly remain the same through recursive calls. It can
sometimes shorten the recursive calls in complex functions defined by
recursion.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=def%20exp%20(base%20:%20nat)%20:%20nat%20%E2%86%92%20nat%0D%0A%20%20%7C%20zero%20:=%20succ%20zero%0D%0A%20%20%7C%20(succ%20p)%20:=%20mult%20base%20(exp%20p)%0D%0A%0D%0Aend%20nat_playground2%0D%0A" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">def</span> <span class="n">exp</span> <span class="o">(</span><span class="n">base</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">succ</span> <span class="n">zero</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mult</span> <span class="n">base</span> <span class="o">(</span><span class="n">exp</span> <span class="n">p</span><span class="o">)</span>

<span class="kn">end</span> <span class="n">nat_playground2</span>
</pre></div>
</div>
</div><div class="section" id="exercise-1-star-factorial">
<h4>Exercise: 1 star (factorial)<a class="headerlink" href="#exercise-1-star-factorial" title="Permalink to this headline">&#182;</a></h4>
</div>
</div>
</div>
<div class="section" id="proof-by-simplification">
<h2>Proof by Simplification<a class="headerlink" href="#proof-by-simplification" title="Permalink to this headline">&#182;</a></h2>
</div>
<div class="section" id="proof-by-rewriting">
<h2>Proof by Rewriting<a class="headerlink" href="#proof-by-rewriting" title="Permalink to this headline">&#182;</a></h2>
</div>
<div class="section" id="proof-by-case-analysis">
<h2>Proof by Case Analysis<a class="headerlink" href="#proof-by-case-analysis" title="Permalink to this headline">&#182;</a></h2>
<div class="section" id="more-on-notation">
<h3>More on Notation<a class="headerlink" href="#more-on-notation" title="Permalink to this headline">&#182;</a></h3>
</div>
<div class="section" id="fixpoints-and-structural-recursion">
<h3>Fixpoints and Structural Recursion<a class="headerlink" href="#fixpoints-and-structural-recursion" title="Permalink to this headline">&#182;</a></h3>
</div>
</div>
<div class="section" id="more-exercises">
<h2>More Exercises<a class="headerlink" href="#more-exercises" title="Permalink to this headline">&#182;</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Software Foundations in Lean</a></h1>








<!-- <h3>Navigation</h3> -->
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">Preface</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Functional Programming in Lean</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-and-functions">Data and Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#proof-by-simplification">Proof by Simplification</a></li>
<li class="toctree-l2"><a class="reference internal" href="#proof-by-rewriting">Proof by Rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#proof-by-case-analysis">Proof by Case Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="#more-exercises">More Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="induction.html">Proof by Induction</a></li>
<li class="toctree-l1"><a class="reference internal" href="lists.html">Working with Structured Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="poly.html">Polymorphism and Higher-Order Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">More Basic Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="logic.html">Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="indprop.html">Inductively Defined Propositions</a></li>
<li class="toctree-l1"><a class="reference internal" href="maps.html">Total and Partial Maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="proofobjects.html">The Curry-Howard Correspondence</a></li>
<li class="toctree-l1"><a class="reference internal" href="indprinciples.html">Induction Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="rel.html">Properties of Relations</a></li>
<li class="toctree-l1"><a class="reference internal" href="imp.html">Simple Imperative Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="impparser.html">Lexing and Parsing in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="impcevalfun.html">An Evaluation Function for Imp</a></li>
<li class="toctree-l1"><a class="reference internal" href="extraction.html">Extracting C++ from Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="auto.html">More Automation</a></li>
<li class="toctree-l1"><a class="reference internal" href="postscript.html">Postscript</a></li>
<li class="toctree-l1"><a class="reference internal" href="bib.html">Bibliography</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="software_foundations_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad, Leonardo de Moura, and Soonho Kong.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/vol1/basics.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>